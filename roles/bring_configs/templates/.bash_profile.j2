#!/bin/bash
{% if  include.comments is defined and include.comments %}
# By default, bash reads these files when it is invoked as a login shell (see INVOCATION below).

# When bash is invoked as an interactive login shell, or as a non-interactive
# shell with the --login option, it first reads and executes commands from the
# file /etc/profile, if that file exists.  After reading  that  file,  it looks
# for  ~/.bash_profile,  ~/.bash_login,  and  ~/.profile,  in  that order, and
# reads and executes commands from the first one that exists and is readable.
# The --noprofile option may be used when the shell is started to inhibit this
# behavior.
{% endif %}


{% if include.common is defined and include.common %}
{% if  include.comments is defined and include.comments %}
############################################
############# COMMON OPTIONS ###############
############################################
{% endif %}
{% if  include.comments is defined and include.comments %}
# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
{% endif %}
export HISTCONTROL=ignoreboth:erasedups
{% if  include.comments is defined and include.comments %}
# append to the history file, don't overwrite it
{% endif %}
shopt -s histappend
{% if  include.comments is defined and include.comments %}
# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
{% endif %}
HISTSIZE=1000
HISTFILESIZE=2000
{% if  include.comments is defined and include.comments %}
# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
{% endif %}
shopt -s checkwinsize
{% endif %}


{#****************************************************************************#}

{% if include.bindings is defined and include.bindings %}
{% if  include.comments is defined and include.comments %}
############################################
########## KEY BINDINGS SECTION ############
############################################
#поиск по истории стрелками вверх/вниз
  {% endif %}
bind '"\e[A": history-search-backward'
bind '"\e[B": history-search-forward'
  {% if  include.comments is defined and include.comments %}
############################################
  {% endif %}
{%endif%}



{#****************************************************************************#}

{% if include.color is defined and include.color %}
{% if  include.comments is defined and include.comments %}
############################################
############### COLORS SECTION #############
############################################
# enable color support of ls and also add handy aliases
{% endif %}
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi
{% endif %}


{#****************************************************************************#}

{% if include.alias is defined %}
{% if  include.comments is defined and include.comments %}
############################################
############### ALIAS SECTION #############
############################################
# enable color support of ls and also add handy aliases
{% endif %}
{% if include.alias.common is defined and include.alias.common %}
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
{% endif %}
{% if include.alias.develop is defined and include.alias.develop %}
alias CD='cd ~/develop'
alias CDA='cd ~/develop/git/marks/ecommerce/env/ansible'
alias CDC='cd ~/develop/git/epam/cheats'
alias CDD='cd ~/develop/git/epam/devops/'
alias CDG='cd  ~/develop/git/github/'
alias CDM='cd ~/develop/git/marks/devops'
alias FIXPASTE='printf "\e[?2004l"'
{% endif %}
{% endif %}


{#
############################################
############### PS1 SECTION #############
############################################
#  \a         an ASCII bell character (07)
#  \d         the date in "Weekday Month Date" format (e.g., "Tue May 26")
#  \D{format} the format is passed to strftime(3) and the result
#             is inserted into the prompt string an empty format
#             results in a locale-specific time representation.
#             The braces are required
#  \e         an ASCII escape character (033)
#  \h         the hostname up to the first `.'
#  \H         the hostname
#  \j         the number of jobs currently managed by the shell
#  \l         the basename of the shell's terminal device name
#  \n         newline
#  \r         carriage return
#  \s         the name of the shell, the basename of $0 (the portion following
#             the final slash)
#  \t         the current time in 24-hour HH:MM:SS format
#  \T         the current time in 12-hour HH:MM:SS format
#  \@         the current time in 12-hour am/pm format
#  \A         the current time in 24-hour HH:MM format
#  \u         the username of the current user
#  \v         the version of bash (e.g., 2.00)
#  \V         the release of bash, version + patch level (e.g., 2.00.0)
#  \w         the current working directory, with $HOME abbreviated with a tilde
#  \W         the basename of the current working directory, with $HOME
#             abbreviated with a tilde
#  \!         the history number of this command
#  \#         the command number of this command
#  \$         if the effective UID is 0, a #, otherwise a $
#  \nnn       the character corresponding to the octal number nnn
#  \\         a backslash
#  \[         begin a sequence of non-printing characters, which could be used
#             to embed a terminal control sequence into the prompt
#  \]         end a sequence of non-printing characters
{% endif %}
txtblk='\e[0;30m' # Black - Regular
txtred='\e[0;31m' # Red
txtgrn='\e[0;32m' # Green
txtylw='\e[0;33m' # Yellow
txtblu='\e[0;34m' # Blue
txtpur='\e[0;35m' # Purple
txtcyn='\e[0;36m' # Cyan
txtwht='\e[0;37m' # White
bldblk='\e[1;30m' # Black - Bold
bldred='\e[1;31m' # Red
bldgrn='\e[1;32m' # Green
bldylw='\e[1;33m' # Yellow
bldblu='\e[1;34m' # Blue
bldpur='\e[1;35m' # Purple
bldcyn='\e[1;36m' # Cyan
bldwht='\e[1;37m' # White
unkblk='\e[4;30m' # Black - Underline
undred='\e[4;31m' # Red
undgrn='\e[4;32m' # Green
undylw='\e[4;33m' # Yellow
undblu='\e[4;34m' # Blue
undpur='\e[4;35m' # Purple
undcyn='\e[4;36m' # Cyan
undwht='\e[4;37m' # White
bakblk='\e[40m'   # Black - Background
bakred='\e[41m'   # Red
badgrn='\e[42m'   # Green
bakylw='\e[43m'   # Yellow
bakblu='\e[44m'   # Blue
bakpur='\e[45m'   # Purple
bakcyn='\e[46m'   # Cyan
bakwht='\e[47m'   # White
txtrst='\e[0m'    # Text Reset

#}

{% if include.ps1 is defined and include.ps1 %}
if [[ $UID == "0" ]];
then
{%if ps1.color_root is defined and ps1.color_root %}
    export PS1='\t \e[1;31m\u@\h\e[1;34m: \w\e[0m\n\$ '
{% endif %}
else
{% if ps1.gray_user is defined and ps1.gray_user %}
    export PS1='\u@\h\e[1;34m: \w\e[0m\$ '
{% endif %}
{% if ps1.color_user is defined and ps1.color_user %}
    export PS1='\e[1;32m\u@\h: \e[1;37m\W\e[0m \$ '
{% endif %}
{% if ps1.color_user_multiline is defined and ps1.color_user_multiline %}
    export PS1='\t \e[1;32m\u@\h\e[1;37m: \w\e[0m\n\$ '
{% endif %}
{%if ps1.developer is defined and ps1.developer %}
    export GIT_PS1_SHOWDIRTYSTATE=1
    export GIT_PS1_SHOWUNTRACKEDFILES=true
    export PS1='\[\033[01;33m\]\t \[\033[01;32m\]\u@\h\[\033[01;34m\] \w\[\033[01;33m\]$(__git_ps1)\[\033[01;34m\] \n\$\[\033[00m\] '
{% endif %}
fi
{% endif %}
